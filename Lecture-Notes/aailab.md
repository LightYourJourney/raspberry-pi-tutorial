# 智能硬件应用实验

北京大学信息科学技术学院

2023年9月

## 前言

“智能硬件应用实验”是一门面向低年级本科生的基础课程，目的是让同学们可以在大学学习的早期阶段了解人工智能的基本概念和应用领域，同时了解计算机硬件设备的简单工作原理。课程内容分成三个主线：Python语言编程、树莓派硬件控制、人工智能算法。

本讲义通过单元实验把相关的知识串联起来，希望学生通过实验可以对本课程三条主线的知识有充分了解。讲义仅对实验本身需要了解的内容进行了简要的介绍，通过实验步骤帮助同学们完成实验。同学们如果需要深入了解相关知识还需要参考讲义中提供的其它参考书籍和网络资料与在线论文。

每个实验内容具有一定的独立性，学生在实验之前必须做好预习，了解实验中所使用硬件的基本原理，掌握相关算法的实现方案，这样才能在实验的过程中充分利用实验室的资源，在有限的实验时间内完成实验，并在学有余力的情况下对相关算法进行深入研究。如果在做实验的过程中遇到困难，也要及时和老师或助教沟通，以免耽误太多时间，不能按时完成实验。

课程的最后还需要同学们完成一个综合项目，利用现有的硬件资源，实现一个有一定趣味性、创新性的智能应用。项目独立完成，可以参考网络上的现有资源，可以使用开源的代码和程序，但必须有自己设计的部分，最后的作品应可以演示。

## 目录

## 第一章 智能硬件简介.....................................................................1

1.1 硬件平台.........................................................................1

1.2 操作系统环境.....................................................................3

1.3 Python编程语言简介..............................................................5

1.4 人工智能简介....................................................................11

## 第二章 简单游戏策略....................................................................14

2.1 电脑游戏中的智能.................................................................14

2.2 树莓派的硬件扩展.................................................................15

2.3 Python 语言控制硬件.............................................................15

2.4 动手实验：猜拳游戏...............................................................19

2.5 思考题..........................................................................20

## 第三章 聚类算法........................................................................21

3.1 聚类算法简介....................................................................21

3.2 1-Wire 总线与传感器..............................................................21

3.3 用到的Python 库.................................................................23

3.4 动手实验：模式识别...............................................................25

3.5 思考题..........................................................................26

第四章 OpenCV 基础...................................................................27

4.1 OpenCV简介....................................................................27

4.2 图片形状检测....................................................................29

4.3 动手实验：图片处理及图形识别.....................................................32

4.4 思考题..........................................................................33

第五章 支持向量机分类器................................................................34

5.1 支持向量机......................................................................34

5.2 SPI OLED 显示模块..............................................................36

5.3 用到的Python库...............................................................41

5.4 动手实验：手写数字识别...........................................................45

5.5 思考题..........................................................................46

## 第六章 构建专家系统....................................................................47

6.1 专家系统........................................................................47

6.2 树莓派的舵机控制................................................................52

6.3 动手实验：动物识别专家....................................................... 58

6.4 思考题..........................................................................59

第七章 OpenCV 进阶...................................................................60

7.1 图片的统计特性..................................................................60

7.2 人脸识别算法基本原理............................................................61

7.3 树莓派对摄像头的处理............................................................63

7.4 运动物体的追踪．．...............................................................64

7.5 动手实验：视频的处理及人脸识别...................................................66

7.6 思考题..........................................................................67

## 第八章 人工神经网络.....................................................................68

8.1 神经网络.........................................................................68

8.2 从线性回归到MLP...............................................................68

8.3PyTorch 简介.....................................................................70

8.4 卷积神经网络（CNN）模型.........................................................72

8.5 模数转换（AD）与数模转换（DA）....................................................74

8.6 动手实验：通过手势识别实时控制发光二极管亮度.....................................77

8.7 思考题..........................................................................87

## 第九章 语音识别和处理入门..............................................................88

9.1 树莓派音频输入输出方法...........................................................88

9.2 HMM-GMM模型介绍.............................................................89

9.3 动手实验：语音控制系统...........................................................91

9.4 思考题..........................................................................92

## 第十章 自然语言处理入门................................................................9310.1 词向量的编码与处理方法...........................................................93

10.2 Twitter 文本情感分析.............................................................97

10.3 未名教学二号集群使用说明....................··········.............100

10.4 动手实验：文本的情感分析.........................................................100

## 第十一章 TensorFlow 应用.............................................................102

11.1 TensorFlow 介绍.................................................................102

11.2 MNIST 入门...................................................................102

11.3 动手实验：物体识别..............................................................105

## 第十二章 大语言模型简介...............................................................106

12.1 Transformer 模型...........................................................106

12.2 大语言模型...................................................................107

12.3 python API接口................................................................108

12.4 动手实验：调用大语言模型........................................................112

## 第十三章 综合实验.....................................................................114

13.1 实验目的.........................................................114

13.2 实验内容......................................................................114

iv 目录

## 第一章 智能硬件简介

随着人工智能（Artifical Intelligence，缩写为AI）相关技术的不断发展，AI已经深入到了社会生活的方方面面。本书将AI技术与电子设备硬件相结合，通过“智能硬件”这一概念，把智能算法通过真实的硬件平台实现。读者在学习智能算法的同时还能了解微处理器系统的基本知识，掌握使用不同的硬件模块实现真实的智能设备的方法。

### 1.1 硬件平台

我们探讨的AI技术大部分只是一种算法，可以在通用计算机上进行研究和验证。如果要把相关技术实现为产品，就必须使用更加经济的硬件平台。这些硬件平台必须具有一定的运算能力，可以运行特定的算法，而实现算法最高效的平台就是微处理器。本书将使用树莓派（Raspbian Pi）作为主要的硬件，完成全部算法的实现。

#### 1.1.1 树莓派简介

###### 图1.1：树莓派

树莓派（Raspberry Pi）是一款基于ARM的微型电脑主板，外观尺寸仅有信用卡大小，却具有电脑的所有基本功能，又称卡片式电脑。树莓派以SD／MicroSD卡为内存硬盘，卡片主板周围有1/2/4个USB 接口和一个10／100以太网接口（A型没有网口），可连接键盘、鼠标和网线，同时拥有视频模拟信号的电视输出接口和HDMI高清视频输出接口，以上部件全部整合在一张仅比信用卡稍大的主板上，具备所有PC 的基本功能，只需接通显示器和键盘，就能执行如电子表格、文字处理、玩游戏、播放高清视频等诸多功能。树莓派与外设的接口和连接方式如图1.2所示。

树莓派问世于2012年，2019年推出了树莓派4。树莓派第4代B型搭载了1.5GHz的64位四核处理器（ARM Cortex-A72 1.5GHz 64-bit quad-core ARMv8 CPU），2GB内存，支持802.11b／g／n／ac无线网卡，低功耗蓝牙5.0，两个USB 2.0和两个USB 3.0接口，1个千兆网接口，两个支持4k分辨率的hdmi 显示接口。树莓派4B型外观如图1.3所示。它通过USB Type-C接口供电，至少可以提供2A的电流才可

###### 图1.2：树莓派的连接与扩展方式

以保证正常的工作。

###### 图1.3：树莓派4代B型外观及接口配置

树莓派4代B型可直接外接显示器和键盘鼠标实现基本的输入输出。树莓派4代B型具有HDMI 视频输出接口，可通过HDMI接口连接显示器输出树莓派的显示界面。键盘和鼠标可通过树莓派提供的USB接口连接到树莓派。

树莓派也可以通过网络连接进行访问，常用的方式是通过SSH（Secure Shell）访问树莓派，SSH是专为远程登录会话和其他网络服务提供安全性的协议。SSH客户端适用于多种平台，Windows操作系统下

常用的SSH客户端软件包括XShell、Putty 以及 SSH Secure Shell Client 等软件。

树莓派还可以通过远程登录的方式使用图形界面，所使用的协议为VNC（Virtual Network Console）。使用前必须首先在树莓派的操作系统中安装VNC服务器，比如 tightvncserver，然后在其它计算机使用VNC客户端登录。Windows操作系统下常见的客户端有ReadVNC，VNC Viewer等。

### 1.2 操作系统环境

树莓派中运行的操作系统是定制的Raspbian，它基于Debian的Linux发行版，专门为树莓派的硬件所优化。Linux操作系统内核是1991年由芬兰学生Linux Torvalds首先公开发布的，它的发行遵循GPL （GNU general public license）协议，在Internet 上不断被发展和完善。由于Linux的开放源代码的特性，很多优秀的程序员加入到Linux的开发行列，使得Linux的发展非常迅速，成为今天无论在服务器平台还是在嵌入式平台都非常具有竞争力的操作系统。

#### 1.2.1 Linux 命令行简介

登录到树莓派操作系统中之后可以使用图形界面完成基本的文件操作和环境设置，但要更加灵活的使用Linux操作系统，或者需要通过字符协议远程登陆树莓派，就需要掌握Linux的常用字符命令。在图形界面下可以打开模拟终端获得命令行操作界面，这里列举了一些命令的功能（方括号中内容为命令参数），具体的使用方法还需要通过在线帮助或其它资料来熟悉。

### 1．文件操作

·更改当前目录：cd［dir］

·创建目录：mkdir［dir］

·删除目录：rmdir［dir］

·列出当前目录文件：ls

·将file1 复制到 file2：cp file1 file2

·删除文件：rm［file］

·显示文本文件内容：more［file］

### 2．网络操作

·查看IP地址：ip addr

·测试网络连通性：ping ［IP］

·通过ssh协议复制文件：scp

### 3．其它命令

·显示磁盘占用情况：df

·显示当前日期和时间：date

·显示命令的说明信息：man［command］

·安装软件 soft：apt-get install ［soft］

·退出当前会话：exit

想熟悉命令行的使用就必须多尝试，充分理解命令的精确含义，许多命令都具有“--help”参数用来显示简单的帮助信息，或者使用man命令来查找手册。

#### 1.2.2 Bash 使用技巧

在Linux系统中，响应用户输入指令的程序被称为shell。比较常用的shell有csh、zsh和bash。由于多数发行版的默认shell都是bash，这里就简单介绍一下它的操作特点。

首先是命令补全功能，它可以大大提高用户在命令行工作的效率。当输入一个比较长的命令的时候，用户可以只输入这个命令的开头几个字母，然后按＜Tab＞键。如果当前系统可以搜索到的命令中以这几

个字母开头的只有一个，系统就会自动把这个命令补全；否则再次输入＜Tab＞键可以显示出所有满足条件的命令，用户可以继续输入字母直到满足的命令只有一个的时候再按＜Tab＞键补全。

命令补全功能还适用于目录名和文件名的补全，在其他软件的辅助下还可以支持命令行参数的补全。例如当前目录中只有一个目录，用户可以如下输入将目录名补全。

1 &#36; cd &lt;Tab&gt;

另外一个功能是命令历史记录，bash会自动记录用户输入的所有命令，用history命令可以查看输入命令的历史。默认情况下，bash会记录最近输入的500条命令。在命令提示符下，按“上”方向键可以调出以前输入的命令，也可以用“下”方向键回到之后输入的命令。使用Ctr1＋r按键组合还可以对历史进行查找，可以根据接下来输入的内容在历史记录中寻找最佳的匹配。

#### 1.2.3 编辑器使用

树莓派自带的xPython 编辑和调试器是Thonny，大多数情况可以满足编程的要求，这里另外还要介绍的是Linux系统自带的vi编辑器。

vi是所有Linux发行版都提供的一个文本编辑软件。但vi和Windows下的任何其他编辑器都不类似，初次接触很可能完全无法了解它的用法。但在某些特殊环境，如嵌入式系统中，也许vi就是唯一的选择。另外，vi是所有Linux和UNIX都包括的命令，掌握了它的用法就可以在所有Linux系统中进行编辑了。

vim是vi的“超集”，它提供更加丰富的功能，更加适合编程的使用。扩展的功能包括语法高亮、多级撤销、可视选择等。大多数Linux发行版提供的都是vim。vim的另一个扩展是gvim，它提供了图形化的工作前端，可以使用鼠标和操作菜单。执行vi file＿name进入vi的界面。vi是一个有“模式”的编辑器，它具有“命令”、“命令行”和“编辑”三种主要模式。刚执行的vi处于命令状态。按“i”键进入插入状态就可以进行文字编辑了。编辑完成后按“Esc”键则可以返回命令状态，在命令状态按“：”键进入命令行状态，在命令行状态输入wq＜回车＞（write and quit）就可以存盘退出。

vi的命令状态主要是通过按键完成特定的功能，例如：

1．x：删除光标位置的字符

2．dd（连续按两次d键）：是删除并保存当前行到缓冲区

3．p：将缓冲区中内容输出到光标位置。

4．yy：保存当前行到缓冲区

5．u：取消上一次操作

6．h，l，j，k：左、右、下、上移动光标

上面提到的命令都要注意区分大小写，它们前面还可以加数字前缀，例如20j就是下移20行光标。

在命令状态按“：”进入命令行状态，输入的“：”在窗口的最低端显示，如下面的例子所示。删除这个输入的冒号可以退出命令行状态。这个状态用来输入比较复杂的命令，例如查找替换：

1


<table border="1" ><tr>
<td colspan="1" rowspan="1">:s/0ne/1/g</td>
</tr></table>

s命令代表替换。第一个“／”号后面的是查找内容，第二个“／”后面是替换内容，第三个“／”后面是一个标志，g代表替换本行的所有目标。

vi的查找命令支持正则表达式，例如使用“＊”号进行模式匹配，熟练掌握正则表达式可以完成复杂的编辑功能。

在命令行状态的一个重要功能就是帮助，使用

就可以查看上面介绍的s命令的说明。在查看帮助的时候，如果有其他条目的链接，则可以按“"Ctrl+]"组合键跳转过去，然后按“Ctrl＋T”组合键返回。

到目前为止已经介绍过好多“求助”的方法了。主要目的是告诉大家如何利用Linux来自己帮助自己，这是加快掌握Linux的捷径。因为没有任何一本书可以包揽Linux的所有功能和用法，只有在遇到难题的时候学会如何自己解决，才能真正掌握Linux的精髓。

### 1.3 Python编程语言简介

Python 语言是一种面向对象的解释型计算机程序设计语言，由荷兰人 Guido van Rossum 于 1989年发明，第一个公开发行版发行于1991年。Python语言简单易学，代码简洁易懂，具有丰富和强大的库，封装了包括正则表达式、文档生成、单元测试、线程、数据库、网页浏览器、CGI、FTP、电子邮件、XML、XML-RPC、HTML、WAV文件、密码系统、GUI（图形用户界面）和其他与系统有关的操作。Python 语言的主要缺点是相比于编译性语言其运行速度较慢。

1.3.1 Python 运行环境

Python是一种脚本语言，需要在解释器的帮助下运行。树莓派中安装了两个版本的Python解释器，分别是python2和python3，代表了两个比较流行的版本。如果采用ssh的方式登录到树莓派，直接运行python或者python3就可以打开这两个解释器的交互环境。如果是采用VNC登录或者直接操作树莓派，需要首先打开一个模拟终端环境。树莓派自带的Thonny或Geany也都是比较适合新手使用的集成开发工具。

如图1.4，在菜单中选择附件中的LX终端或者直接单击提示栏中的有“＞＿”符号的图标就可以打开模拟终端，同样运行 python即可。

###### 图1.4：Python 运行环境

起来。

1 &gt;&gt;&gt; print("hello,uworld!")

2 hello,world!

在Python 交互模式下输入exit（）并回车（或者按Ctrl+D)，就退出了Python 交互模式，并回到终端命令行。

Python交互模式的代码是输入一行，执行一行。而命令行下直接运行.py文件是一次性执行该文件内的所有代码。如

1 &#36; python3 hello.py

2 Hello, world!

Python交互模式主要是为了调试Python代码，也便于初学者学习。在Python的交互式命令行写程序，优点是立刻就能得到结果，缺点是没法保存。因此实际编程的时候通常是采用文本编辑器编写Python 代码，编写完成后保存为一个文件，程序就可以反复执行了。Python程序的源代码是纯文本文件，通过缩进来标识不同的语法层次关系，而“＃”号后面的内容为注释，可用来对程序进行解释，提高代码的可读性。

#### 1.3.2 数据类型

Python 语言支持的数据类型包括整数、浮点数、字符串、布尔值以及列表等。Python 可以处理任意大小的整数，当然包括负整数，在程序中的表示方法和数学上的写法一模一样，例如：1,100，-8080,0等。计算机由于使用二进制，所以，有时候用十六进制表示整数比较方便，十六进制用0x前缀和0-9，a-f表示，例如：0xff00,0xa5b4c3d2等。

浮点数可以用数学写法，如1.23,3.14，-9.01等。但是对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x109就是1.23e9，或者12.3e8,0.000012可以写成1.2e-5等。

字符串是以单引号或双引号括起来的任意文本，比如＇abc＇，”xyz”等等。需要注意的是，单引号或双引号本身只是一种表示方式，不是字符串的一部分，因此，字符串＇abc＇只有a，b，c这3个字符。如果单引号本身也是一个字符，那就可以用双引括起来，比如＂I＇m OK”包含的字符是I，＇，m，空格，O，K这6个字符。

布尔值和布尔代数的表示完全一致，一个布尔值只有True、False两种值，要么是True，要么是False，在Python中，可以直接用True、False表示布尔值。

#### 1.3.3 变量

变量是指向各种类型值的名字。在Python中，变量的使用环境非常宽松，没有明显的变量声明，等号＝是赋值语句，可以把任意数据类型赋值给变量。同一个变量可以反复赋值，而且可以是不同类型的变量。这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。

在Python中，如果你不能确定变量或数据的类型，就用解释器内置的函数type确认。例如：

1 &gt;&gt;&gt; a = 'name'

2 type(a)

3 &lt;class 'str'&gt;

4 &gt;&gt;&gt; classmates = ['Michael','Bob','Tracy']

5 &gt;&gt;&gt; type(classmates)

6 &lt;class 'list'&gt;

#### 1.3.4 元组、列表、字典和集合

在程序设计的时候经常需要把多个元素包装到一起来使用，例如纸张的规格、训练的多组数据等。这种可以容纳多个变量的数据结构叫做容器，Python 有多个容器类别，分别适合不同的应用场景。

元组（tuple）是最简单的容器，所有元组元素使用括号包围，例如：

1 BrickSize=(15,23,56)

2 Classmates =('Bill','Carl')

元组一旦建立就不可以改变，里面的元素也可以是不同类型，常用的元组操作可以参考下面示例：

1 1en(BrickSize) ＃获取元组长度

2 print（Classmates［1］）＃通过索引获取元素（第一个元素的索引为0）

3 BrickSize．index（15）＃查找元素的索引号

需要注意的是如果元组只有一个元素，那么定义的时候要在这个元素后面加上逗号，如a=(1,)。

列表（list）是Python内置的另外一种容器类型，他和元组一样是一种有序的集合，但可以随时添加和删除其中的元素。列表中包含的元素可以具有相同的数据类型，也可以具有不同数据类型，例如：

1 Names = ['Michael', 'Sarah','Tracy']

2 0bjects = ['Apple', 123, True]

3 Sizes ＝ ［［10， 20］，［15,25］，［20,35］］＃列表当然也可以嵌套

列表在程序中经常使用，用法也十分灵活，下面是一些应用的例子：

1 Names.append('Sarah') ＃在末尾增加元素

2 Objects.insert(2,456) ＃在索引2的位置插入新元素

3 Objects.pop(2) ＃删除索引2的元素（不加参数缺省删除末尾元素）

4 Sizes.reverse() ＃元素顺序颠倒

5 0bjects.clear() ＃删除全部元素

6 Sizes.sort() ＃对元素进行排序

7 Names.remove('Sarah') ＃根据内容删除元素（只删除第一个匹配）

注意列表在复制的时候只是新建一个引用，所代表的内容是相同的，如果需要完整复制（深复制）一个列表元素，要用copy方法，例如：

1 &gt;&gt;&gt; Names = ['Michael', 'Sarah', 'Tracy']

2 &gt;&gt;&gt;K=Names ＃浅复制

3 &gt;&gt;&gt;Q=Names.copy() ＃深复制

4 ＞＞＞Names.append（＇Violet＇）＃修改原始变量的值

5 &gt;&gt;&gt; K ＃K的值同时被改变

6 ['Michael', 'Sarah', 'Tracy', 'Violet']

7 &gt;&gt;&gt;Q ＃Q的值没有变化

8 ['Michael', 'Sarah', 'Tracy']

和列表类似，字典（dict）也是可以保存多个元素的变量类型，其每个元素都是一个冒号分隔的键值对，例如：

1 ≫dict = {'Alice': '1234', 'Bob': '5678', 'Charlie': '90'}

可以通过“键”对“值”进行查询，也可以对“键”进行赋值，例如：

1 &gt;&gt;&gt; dict.keys() ＃返回全部的键列表

2 dict_keys(['Alice', 'Bob', 'Charlie'])

3

4

5

6

7

字典也包含一些内置的函数，如clear（）清除字典内容；key in dict 查询键是否存在；len（dict）查询字典元素个数等。

集合（set）也与列表类似，但是不能存储重复的数据，并且是没有存放顺序的区别，集合可以通过add（）增加元素，也可以通过remove（）删除元素。比较特别的，集合可以求交集和并集，例如：

#### 1.3.5 序列的下标访问

Python中的字符串、元组和列表都是有序结构，都可以用下标进行访问，可以统称为序列。序列的下标访问主要有下面几种方式：

1．seq［index］获得索引所在位置元素

2． seq［index1：index2（：stride）］获得索引从index1到index2的全部元素，stride是步长，缺省为1，index1 空缺表示从头开始，index2空缺表示到最后一个元素，seq［：］表示全部元素。

3.sec1+sec2连接两个序列

4.$\sec\varphi_{*}\exp_{x}$序列元素重复expr遍

当索引值为负时，它表示从序列最后一个元素开始计数，例如，seq［-1］可以获得序列的最后一个元素。

#### 1.3.6 基本输入输出

在Python中，用print（）函数在括号中加上字符串，就可以向屏幕上输出指定的文字。例如：

1

2


<table border="1" ><tr>
<td colspan="1" rowspan="1">&gt;&gt;&gt;print('hello$,uWorld^{\prime})$hello,$world$&gt;&gt;&gt;$name=$$^{\prime}T\circm^{\prime}$&gt;&gt;&gt; print(name)Tom</td>
</tr></table>

3

4

5

print（）函数也可以接受多个字符串，用逗号“，”隔开，就可以连成一串输出，print（）函数会依次打印每个字符串，遇到逗号“，”会输出一个空格，例如，

1 &gt;&gt;&gt; print('The_brown fox','jumpsuover','theulazyudog.')

2 The brown fox jumps over the lazy dog.

3 &gt;&gt;&gt;$\pi\int(^{x})+(x)=\int(x)dx+c(x)dy=1$,100+200)

4 100+200=300

在Python中，可以利用input（）函数完成基本输入。利用input（）函数可以让用户输入字符串，并存放到指定的变量里。例如，

1


<table border="1" ><tr>
<td colspan="1" rowspan="1">$>>>name=\input()$</td>
</tr><tr>
<td colspan="1" rowspan="1">Michael</td>
</tr></table>

2

当用户输入name=infut()并按下回车后，Python交互式命令行就在等待输入了，用户可以输入任意字符，然后按回车后完成输入。另外，可以在input（）函数加入提示信息。例如，

1 &gt;&gt;&gt; name = input('pleaseuenteruyouruname:u')

2 please enter your name: Michael

3 &gt;&gt;&gt;print('hello,', name)

4 hello, Michael

#### 1.3.7 条件判断

在Python程序中，用if语句实现条件判断。例如，

根据Python的缩进规则，如果if语句判断是True，就执行缩进的两行语执行，否则，什么也不做。也可以给if语句添加一个else语句，如果if判断是False，不执行if后的语句，而是执行else后的语句。需要注意的是if语句和else 语句后面要添加冒号。例如：

1 $food=\intnput(^{\prime}What_{u}douyou_{u}]ikeutoueat7L^{\prime})$

2 if$f\circod==^{\vert}App1e^{\prime}:$

3 $pr\intnt(^{\prime}Please_{L}enjoy^{\prime})$

4 else:

5 print("Sorry,uWeudon'tuhaveuany")

另外，可利用elif语句添加多个条件判断，elif是else if的缩写，可以有多个elif语句。例如：

1 age=int(input('Enteruyouruage:u'))

2 ifarge&gt;=18:

3 print$;(Y\circu_{L}$ $u_{U}are_{U}an_{U}adu1t!^{\prime})$

4 elifage&gt;=6:

5 print ('Youuareuauteenager')

6 else:

7 $pr\intt(^{\prime}You_{U}are_{U}a_{U}kid^{\prime})$

#### 1.3.8 循环

Python的循环有两种，一种是for...in循环，另一种是while循环。for...in 循环可以依次将列表中的每个元素迭代出来。例如：

1 for i in [0,1,2,3,4,5,6,7,8,9]:

2 print(i)

可以利用Python提供的range（）函数控制for循环，range（）函数可以产生一个整数序列。上面利用for循环的求和代码可用range（）函数进行简化。

1


<table border="1" ><tr>
<td colspan="1" rowspan="1">for i in range（0,10）：＃从0循环至9print(i)</td>
</tr></table>

2

另外，range（）函数产生的整数序列可以指定步进值，例如：

1


<table border="1" ><tr>
<td colspan="1" rowspan="1">for i in range（0,10,2）：＃从0循环至9，步进值为2print(i)</td>
</tr></table>

2

Python的while循环只要条件满足就不断循环，条件不满足时退出循环。例如：

1 n=1

2 whilen&lt;=100:

3 pr∈t(n)

4 n=n+1

对于循环语句，可以通过break语句退出循环或通过continue 语句跳过当前循环。例如：


<table border="1" ><tr>
<td colspan="2" rowspan="1">1 $n=1$</td>
</tr><tr>
<td colspan="1" rowspan="1">2</td>
<td colspan="1" rowspan="1">while$n<=100:$</td>
</tr><tr>
<td colspan="1" rowspan="1">3</td>
<td colspan="1" rowspan="1">$ifn>10:$  #当 $n=11$ 时，条件满足，执行 break 语句</td>
</tr><tr>
<td colspan="1" rowspan="1">4</td>
<td colspan="1" rowspan="1">break ＃结束当前循环</td>
</tr><tr>
<td colspan="1" rowspan="1">5</td>
<td colspan="1" rowspan="1">print(n)</td>
</tr><tr>
<td colspan="1" rowspan="1">6</td>
<td colspan="1" rowspan="1">$n=n+1$</td>
</tr><tr>
<td colspan="1" rowspan="1">7</td>
<td colspan="1" rowspan="1">print('END')</td>
</tr><tr>
<td colspan="1" rowspan="1">8</td>
<td colspan="1" rowspan="1">$n=0$</td>
</tr><tr>
<td colspan="1" rowspan="1">9</td>
<td colspan="1" rowspan="1">while$n<10:$</td>
</tr><tr>
<td colspan="1" rowspan="1">10</td>
<td colspan="1" rowspan="1">$n=n+1$$2$</td>
</tr><tr>
<td colspan="1" rowspan="1">11</td>
<td colspan="1" rowspan="1">$ifn\%$ $=$$。$:#如果n是偶数，执行continue语句</td>
</tr><tr>
<td colspan="1" rowspan="1">12</td>
<td colspan="1" rowspan="1">continue ＃ 跳过当前循环</td>
</tr><tr>
<td colspan="1" rowspan="1">13</td>
<td colspan="1" rowspan="1">print (n)</td>
</tr></table>

#### 1.3.9 Python的文件操作

在操作文件之前，需要先把文件打开，操作之后还需要把文件关闭，与这两个操作对应的函数是open 和close。open操作返回一个文件类，后续对这个文件的操作都通过这个类来进行。open函数的定义如下：

1 open(name[, mode[,buffering]])

其中name 参数为文件的名称，mode为文件的打开方式，buffering表示缓冲区的大小。最常用的mode 参数为”r”和＇$^{25}W^{35}$，分别代表读和写的方式，当用”w”的方式打开时，如果文件已经存在，则里面的内容会被清空。还有一种”a”方式用来在文件后面添加新的内容。另外＂r＋”、”w＋”和”a＋”都以读写方式打开文件，但”w＋”会清空文件，”a＋”会将文件指针放到文件末尾。

文件操作包括文件的读和写，对于文本文件，可以认为其内容是一个字符串数组，每个字符串代表文件的一行，这样就可以利用下面的示例代码将整个文件读入。

1 f = open(filename,'r')

2 limes=f.readl∈es()

3 f.c1ose()

文件主要使用write函数将数据写入，简单示例如下：

1


<table border="1" ><tr>
<td colspan="1" rowspan="1">f= open(filename, 'a')$f.Write('Lastul\ine(n^{\prime})$f.close()</td>
</tr></table>

2

3

#### 1.3.10 Python 库

Python 语言可以通过库来进行扩展，实现一些在特定领域比较常见的算法，供所有软件开发人员来使用，大大提高了Python语言的开发效率。本书后续介绍的人工智能算法很多都有相应的库来支持，复杂的运行过程可以通过简单几个Python语句来实现，降低了人工智能的应用门槛，这也使得Python成为人工智能开发中最常用的编程语言。

在Python的发行版中还包含了大量的标准库，可以在不额外安装软件的前提下使用。例如文件系统的操作、常用数据类型、常用算法等等。例如 random 库实现了常用随机数的产生，random（）函数在［0,1）区间生成均匀分布的随机浮点数。randint（a，b）函数返回在［a，b］区间的均匀分布整数。例如，下面代码生成了十个随机整数。

1 import random ＃导入 random 模块

2 data=[] ＃定义一个空的列表 data

3 for i in range(0,10):

4 data.append(random.randint(0,99))

Python标准库的资料可以参考官方的在线文档（https：／／docs．python．org／zh-cn／3／library／），了解标准库所包含的内容并在程序中进行运用可以简化代码设计，保证代码的质量。

#### 1.3.11 Python程序的编写和调试

对于新手来说，直接使用Vim编辑源代码来开发Python 程序确实有些难度，树莓派操作系统中安装的Thonny则是一个更好的选择。它是一个简单的Python集成开发环境，支持语法高亮、代码补全、单步调试等功能，可以方便的编写Python代码。图1.5是Thonny的运行界面，上半部分是编辑的程序代码，下半部分是程序的运行结果。

点击工具栏上的调试按钮或者在Run菜单中选择Debug命令就可以对程序进行单步调试。单步调试时可以选择Step Over（快捷键F6）一次执行一条语句，对于函数和类方法等可以一次跳过；也可以选择Step Into（快捷键F7）在遇到函数和类方法时可以进入模块内部单步执行。Step Out（快捷键F8）是跳出当前模块，表示进入到函数和类方法时执行到这个模块的末尾，跳到上一层级的代码。

在编写程序时熟练使用调试功能可以帮助新手快速熟悉语言功能，找出程序中存在的bug，加深对Python程序运行过程的理解。

### 1.4 人工智能简介

“智能”在新华字典中的定义是“智慧和能力”。这个过分简单的解释并不能让我们清楚的了解什么是智能。实际上，对于人类如何思考，如何解决问题，科学家们依然没有明确的答案。大自然经过千百万年的进化发展，使人类具备了智慧的大脑，可以对物理世界进行观察和分析，并创造出自然界不存在的工具来为人类服务。如今，人类的创造目标包括了智能，这也就是人工智能的主要研究方向。

人类对智能的探索其实古已有之，在《列子》中就记载了偃师设计的木人为周穆王跳舞的故事，这个木人不但可以跳舞说话，还可以抛媚眼。中国古书中记载的类似故事还有很多，不过都没有原理说明，更没有图纸，只能是当时人们的美好幻想。也从另外一个侧面说明人类对自身的思维和运动能力一直具有强烈的

###### 图1.5：Thonny的运行界面

好奇心，想了解其背后的原理，并制造出相应的工具。可以认为这种非天然的人类工具具有的智能就是人工智能，与之相关的科学研究组成了人工智能这一学科方向。

人类的智能有很多类别，比如运动能力、计算能力、语言能力、视觉识别能力、逻辑分析能力等等。其中一些能力需要与其它能力配合才可以算作具有智能。比如运动能力，人类很早就可以制造出远超人类力量与速度的工具，但这些还需要人的操作，并不具有智能。最近发展起来的类人机器人则需要复杂的计算模型，并配合视觉处理、逻辑推理等多个模块才可以获得差强人意的效果；智能汽车自动驾驶也是需要多种传感器和算法的支持才能在公路上自由行驶。

下面表格列举了一些常见的人工智能研究方向，而本书也只是涉及了其中的一小部分。

###### 表1.1：人工智能研究方向


<table border="1" ><tr>
<td colspan="1" rowspan="1">研究方向</td>
<td colspan="1" rowspan="1">简单描述</td>
</tr><tr>
<td colspan="1" rowspan="1">自然语言处理</td>
<td colspan="1" rowspan="1">研究通过文本或者音频进行语言交流的设备或者程序</td>
</tr><tr>
<td colspan="1" rowspan="1">逻辑推理</td>
<td colspan="1" rowspan="1">一种专门用于推理的编程语言，如Prolog、Datalog等</td>
</tr><tr>
<td colspan="1" rowspan="1">机器视觉</td>
<td colspan="1" rowspan="1">让计算机从图片或者视频中获取信息并进行处理</td>
</tr><tr>
<td colspan="1" rowspan="1">机器学习</td>
<td colspan="1" rowspan="1">使计算机可以通过学习提高算法的性能</td>
</tr><tr>
<td colspan="1" rowspan="1">机器人</td>
<td colspan="1" rowspan="1">通过算法使机器可以执行复杂的动作任务</td>
</tr><tr>
<td colspan="1" rowspan="1">情感计算</td>
<td colspan="1" rowspan="1">通过视觉或文本等识别和处理或者模拟人类的情感</td>
</tr><tr>
<td colspan="1" rowspan="1">认知理论</td>
<td colspan="1" rowspan="1">研究人类思维的结构，通过计算机对大脑进行建模</td>
</tr><tr>
<td colspan="1" rowspan="1">游戏智能</td>
<td colspan="1" rowspan="1">在游戏中让非人类玩家具有类似真实人类的表现</td>
</tr><tr>
<td colspan="1" rowspan="1">智能助理</td>
<td colspan="1" rowspan="1">类似目前手机中常见的语音助手，帮助人们完成一些简单任务</td>
</tr><tr>
<td colspan="1" rowspan="1">专家系统</td>
<td colspan="1" rowspan="1">将知识用计算机可以理解的方式进行表达，使计算机可以完成需要大量知识的复杂任务</td>
</tr></table>

虽然目前人类对自己大脑的了解还不能解释智能的产生，但人工智能的发展却丝毫不受影响。大部分的人工智能研究并不基于人类智能的原理，而主要依靠背后的数学原理和电子学技术。随着计算能力的提

升和人工智能研究的深入，很多从前看起来非常困难的任务已经被实现。机器图像识别已经在很多工业领域获得应用，自然语言处理也可以在电话和网络客服中很好的工作，围棋比赛也没有人类可以战胜电脑，人工智能正进入一个蓬勃发展的阶段，不断有新的算法出现，计算机的“智能”水平正不断获得提升。

在人工智能领域，python语言的使用十分普遍，很多算法都通过python语言实现并以开源的方式发布在网络上。为了更方便的实现人工智能应用，python语言还发展出很多程序框架，比较著名的有scikit-learn、TensorFlow、PyTorch、Caffe、Theano等。对于比较复杂的人工智能应用，由于需要强大的计算资源，很多AI公司也都公开了网络调用API，可以利用云资源来实现特定的功能。

## 第二章 简单游戏策略

本章我们用树莓派制作一个猜拳机器人，玩家可以通过按键输入手势类型与树莓派对抗，树莓派则通过一定的算法提高自己的胜率。通过本章的学习，读者可以掌握树莓派GPIO的基本用法，并加深对Python 语言的理解。

### 2.1电脑游戏中的智能

相信大部分读者都玩过电脑游戏，而电脑游戏中又有很大一部分是对抗性的。在电脑游戏中，玩家的对手-电脑-必然具有一定的“智能”才能使得游戏比较“有趣”。对于不同的游戏类型，所需要的智能算法也不同，这里仅讨论有限状态、公开信息的简单对抗游戏，例如猜拳游戏。通过这个大家都很熟悉的游戏，探讨可能涉及到的算法。

### 2.1.1 随机策略

就像人类有时会通过抛硬币来决定一些事情，计算机通过产生随机数的方法来进行决策是最简单而往往也很有效的方法。比如在猜拳游戏中，如果一方采用完全随机的出拳策略，理论上胜负也同样随机，因此会有50％左右的胜率，不算好也不算差。

但目前大部分随机数发生器都是伪随机序列，虽然看起来分布比较均匀，却是通过公式产生，可以通过一定的算法来预测。经典的随机数产生方法是线性同余法（Linear Congruence Generator，LCG），其基本公式如下：

$X_{n+1}=(aX_{n}+c)modm$ (2.1)

线性同余法定义了三个常数：乘量a、增量c和模数$m,X_{i}$为生成的随机数序列。为了保证产生的随机数可以获得最大周期（不重复长度），这三个常数应该符合：

1．m与c互质

2．m的所有质因数都能整除a-1

3．若m是4的倍数，a-1也是4的倍数

4．a、c都是正数，还要比m小

对于比较简单的情况，游戏一方仅初始化一次随机数（$(X_{0}$的取值，即随机数的种子），游戏另一方就有可能猜到这个种子，并正确预测出后续产生的全部随机数，所谓的随机性也就完全丧失了。为了获得更好的随机数，可以采用更好的算法，或者采用可以产生真随机数的物理硬件来实现。

### 2.1.2 根据历史数据进行决策

在多次重复游戏中，游戏历史数据可以作为分析对象，简单的历史模式匹配就可以成为很好的策略：当各方面条件都相同时，采用一个过去曾经成功的动作获胜的概率会比较大。而如果考虑到对方也会分析历史，那么曾经采用的动作有可能被针对，相对要降低选择的概率。

部分多次重复的游戏运行过程可以抽象成马尔可夫链：从一个游戏状态到另外一个状态的转换状态概率可以视为常数。这样经过几轮游戏之后，就可以积累一定的数据，并根据统计信息计算状态转移的概率。

假设模型的状态空间为$S_{i},i=1,\cdots,n,$，动作空间为$A_{i},i=1,\cdots,m。$。则在特定状态下采取某种动作的概率可以表示为$P(A_{i}\vertS_{j})$。对于多阶情况则可以表示为：$P(A_{i})\vertS_{j_{1}},S_{j_{2}},\cdots,S_{jk})。$

对于猜拳游戏，根据双方的出拳状态，一共有9种可能，那下一次的出拳概率可以根据这9种情况采取不同的概率应对。而对方的出拳概率可以根据历史统计资料获得。上面只是考虑了一阶的情况，对于高阶情况则需要考虑更多的历史状态。

### 2.1.3 利用深度学习进行决策

前面的方法都是利用了人类的经验来设计策略，能不能通过人工学习的方式获得更好的策略呢？这也是目前人工智能研究中的重要分支，在很多领域也已经获得了很好的结果。例如著名的Alpha-Zero 就可以完全通过学习，在围棋游戏中打败人类顶尖高手。

### 2.2 树莓派的硬件扩展

#### 2.2.1 树莓派 GPIO 接口简介

在嵌入式系统中，经常需要控制许多结构简单的外部设备或者电路，这些设备有的需要由CPU提供输出信号，有的需要向CPU提供输入信号，并且许多设备或电路只要求有开／关两种状态就可以满足使用需要，例如比如LED的亮与灭。对此类设备的控制，使用传统的串口或者并口就显得比较复杂。

在嵌入式微处理器上通常提供了一种“通用可编程I／O端口”，也就是GPIO（General Purpose Input Output）。一个GPIO端口至少需要两个寄存器，一个做控制用的“通用IO端口控制寄存器”，还有一个是存放数据的“通用I／O端口数据寄存器”。数据寄存器的每一位是和GPIO的硬件引脚对应的，而数据的传递方向是通过控制寄存器设置的，通过控制寄存器可以设置每一位引脚的数据流向。

GPIO是树莓派最强大的特点之一，它也是树莓派与外部世界交互的物理接口之一。如图1.3所示，树莓派型提供了40个GPIO引脚可用于对简单外设进行控制。树莓派40个GPIO引脚定义如图2.1所示。

#### 2.2.2 PIONEER600 树莓派扩展板简介

Pionner600扩展板是一款Raspberry Pi的外围扩展板，带有丰富的板载资源，扩展了多种常用接口，提供了一些简易的I／O设备，例如LED指示灯、五向遥杆等。Pionner600 扩展板的外观与配置如图2.2所示。

### 2.3 Python 语言控制硬件

#### 2.3.1 RPi．GPIO的基本使用

树莓派 RPi.GPIO Python 模块提供了GPIO相关的操作包括GPIO接口的配置、输入及输出等。下面的语句实现RPi.GPIO模块的导入：

1 import RPi.GPIO as GPIO

通过该操作完成了RPi.GPIO模块的导入，并为其定义了一个别名GPIO，在之后的程序中可通过别名使用RPi.GPIO模块。


<table border="1" ><tr>
<td colspan="3" rowspan="1">Raspberry Pi2 GPIO HeaderPin# NAME NAME Pin#</td>
</tr><tr>
<td colspan="1" rowspan="1">01 3.3v DC Power</td>
<td colspan="1" rowspan="20"></td>
<td colspan="1" rowspan="1">DC Power 5v 02</td>
</tr><tr>
<td colspan="1" rowspan="1">03 GPIO02 (SDA1,PC)</td>
<td colspan="1" rowspan="1">DC Power 5v 04</td>
</tr><tr>
<td colspan="1" rowspan="1">05 GPIO03 (SCL1,PC)</td>
<td colspan="1" rowspan="1">Ground 06</td>
</tr><tr>
<td colspan="1" rowspan="1">07 GPIO04 (GPIO_GCLK)</td>
<td colspan="1" rowspan="1">(TXD0) GPIO14 08</td>
</tr><tr>
<td colspan="1" rowspan="1">09 Ground</td>
<td colspan="1" rowspan="1">(RXD0) GPIO15 10</td>
</tr><tr>
<td colspan="1" rowspan="1">11 GPIO17 (GPIO_GEN0)</td>
<td colspan="1" rowspan="1">(GPIO_GEN1) GPIO18 12</td>
</tr><tr>
<td colspan="1" rowspan="1">13 GPIO27 (GPIO_GEN2)</td>
<td colspan="1" rowspan="1">Ground 14</td>
</tr><tr>
<td colspan="1" rowspan="1">15 GPIO22 (GPIO_GEN3)</td>
<td colspan="1" rowspan="1">(GPIO_GEN4) GPIO23 16</td>
</tr><tr>
<td colspan="1" rowspan="1">17 3.3v DC Power</td>
<td colspan="1" rowspan="1">(GPIO_GEN5) GPIO24 18</td>
</tr><tr>
<td colspan="1" rowspan="1">19 GPIO10 (SPI_MOSI)</td>
<td colspan="1" rowspan="1">Ground 20</td>
</tr><tr>
<td colspan="1" rowspan="1">21 GPIO09 (SPI_MISO)</td>
<td colspan="1" rowspan="1">(GPIO_GEN6) GPIO25 22</td>
</tr><tr>
<td colspan="1" rowspan="1">23 GPIO11 (SP_CLK)</td>
<td colspan="1" rowspan="1">(SPI_CE0_N) GPIO08 24</td>
</tr><tr>
<td colspan="1" rowspan="1">25 Ground</td>
<td colspan="1" rowspan="1">(SPI_CE1_N) GPIO07 26</td>
</tr><tr>
<td colspan="1" rowspan="1">27 ID_SD(R2C ID EEPROM)</td>
<td colspan="1" rowspan="1">(PC ID EEPROM) ID_SC 28</td>
</tr><tr>
<td colspan="1" rowspan="1">29 GPIO05</td>
<td colspan="1" rowspan="1">Ground 30</td>
</tr><tr>
<td colspan="1" rowspan="1">31 GPIO06</td>
<td colspan="1" rowspan="1">GPIO12 32</td>
</tr><tr>
<td colspan="1" rowspan="1">33 GPIO13</td>
<td colspan="1" rowspan="1">Ground 34</td>
</tr><tr>
<td colspan="1" rowspan="1">35 GPIO19</td>
<td colspan="1" rowspan="1">GPIO16 36</td>
</tr><tr>
<td colspan="1" rowspan="1">37 GPIO26</td>
<td colspan="1" rowspan="1">GPIO20 38</td>
</tr><tr>
<td colspan="1" rowspan="1">39 Ground</td>
<td colspan="1" rowspan="1">GPIO21 40</td>
</tr><tr>
<td colspan="3" rowspan="1"></td>
</tr></table>

###### 图2.1：树莓派GPIO引脚定义

目前有两种方式可以通过RPi.GPIO对树莓派上的IO引脚进行编号。第一种方式是使用BOARD 编号系统。该方式参考树莓派主板上P1接线柱的引脚编号。使用该方式的优点是无需考虑主板的修订版本，硬件始终都是可用的状态，无需从新连接线路和更改您的代码。

第二种方式是使用BCM编号。这是一种较低层的工作方式。该方式参考Broadcom SOC的通道编号，具体的对应关系可参考图2.1，使用过程中，要保证主板上的引脚与图表上标注的通道编号相对应。在使用GPIO时必须指定使用哪种编号方式，指定方式如下：

1

2


<table border="1" ><tr>
<td colspan="1" rowspan="1">GPIO.setmode（GPIO.BOARD）＃采用 BOARD 编号</td>
</tr><tr>
<td colspan="1" rowspan="1">＃或者</td>
</tr><tr>
<td colspan="1" rowspan="1">GPIO.setmode（GPIO.BCM）＃采用 BCM 编号</td>
</tr></table>

3

在使用GPIO输入输出前，需要对每个用于输入或输出的引脚配置通道。配置的方式如下：

1

2

3


<table border="1" ><tr>
<td colspan="1" rowspan="1">＃配置 channel 指定的通道为输入通道＃channel 与使用的编号方式对应GPIO.setup(channel, GPIO.IN,GPIO.PUD_UP)＃配置 channel 指定的通道为输出通道GPIO.setup(channel, GPIO.OUT)</td>
</tr><tr>
<td colspan="1" rowspan="1">＃ 配置 channel 指定的通道为输出通道，且规定通道初始输出高电平GPIO.setup(channel,GPIO.OUT, initial=GPIO.HIGH)</td>
</tr></table>

在设置为输入状态的时候，如果外部电路没有连接上拉电阻，可以通过GPIO.PUD＿UP参数设置

#### ［核心接口简介］ 7.蜂鸣器

1． Raspberry Pi GPIO 接口 8.CP2102

方便接入RPi USB转串口芯片

2． USB TO UART 接口 9.PCF8591

方便通过申口终端控制 Raspberry Pl 8位精度AD／DA芯片，12C接口

3.AD／DA输入输出接口（接线端子） 10.BMP180

方便在各种场合使用 压力传感器，12C接口

4.ONE-WIRE 接口 11. PCF8574

可接入DS18B20等单总线设备 1／O扩展芯片，12C接口

5．传感器接口 12. DS3231

方便接入各类传感器 高精度RTC芯片，12C接口

［器件简介］ 13．电源LED

6． 0.96寸OLED 14．用户 LED

驱动芯片为SSD1306,128x64分辨率， 15．五向摇杆

SPI接口 16． LFN0038K红外接收头

###### 图2.2：PIONEER600树莓派扩展板

GPIO的内部上拉电阻有效，以保证输入端在没有接入信号的时候有确定的输入值（1）。完成通道的配置后，就可以通过通道读取GPIO引脚的值或者设置GPIO引脚的输出状态。

1

2

3


<table border="1" ><tr>
<td colspan="1" rowspan="1">GPIO.input（channel）＃ 读取 GPIO 引脚的值＃引脚的值：0／GPIO．LOW／False 或者 1／GPIO．HIGH／True．GPIO.output(channel,state)＃设置 GPIO 引脚的输出状态为 state＃ State 的值：0／GPIO．LOW／False 或者 1／GPIO．HIGH／Tru</td>
</tr></table>

4

5

脉宽调制（PWM）是指用微处理器的数字输出来对模拟电路进行控制，是一种对模拟信号电平进行数字编码的方法。在树莓派上，可以通过对GPIO的编程来实现脉宽调制。RPI.GPIO模块的脉宽调制（PWM）功能的基本使用方式如下：

1

2

3

4


<table border="1" ><tr>
<td colspan="1" rowspan="1">＃创建一个通道 channel 的PWM 实例pwm = GPIO.PWM(channel, frequency)＃ 启动 PWM ，并指定占空比 dc， dc 的范围0.0～100.0pwm.start(dc)＃更改PWM脉冲重复的频率为 frequencypwm.ChangeFrequency(freq)＃更改PWM的占空比为dcpwm.ChangeDutyCycle(dc)＃停止 PWM</td>
</tr></table>

5

6

7

8

9

10 pwm.stop()

一般来说，程序到达最后都需要释放资源，这个好习惯可以避免偶然损坏树莓派。释放程序本中使用的引脚如下：

1 GPIO.cleanup()

注意，GPIO.cleanup（）只会释放掉脚本中使用的GPIO引脚，并会清除设置的引脚编号规则。

#### 2.3.2 按键检测

利用树莓派上GPIO接口实现按键的输入检测。Pioneer600扩展板上扩展了一个五向遥杆，遥杆可上下左右拨动，也可以按下。遥杆按下的输入接到了树莓派GPIO的第38号引脚，BCM编号为20（即图2.1中GPIO20）。可以利用树莓派RPi．GPIO模块实现对Pioneer600扩展板五向遥杆的按键输入检测，按下一次按键就在屏幕上打印＂KEY PRESS”。下面代码实现了对按键输入GPIO通道的初始化。

完成测试按键程序的过程中注意要保证每次按键只有一次输出信息（消抖），同时检测按键间隙要有延时，免得占用过多CPU时间。

另外一种实现检测按键的方式是利用软件中断和回调函数，GPIO模块包含add＿event＿detect 函数，用来设置发生指定事件时刻的回调函数：

1 from RPi.GPIO import add_event_detect

2 def my_callback(ch):

3 print("KEY PRESS")

4 add_event_detect(channel,GPIO.RISING,callback=my_callback,bouncetime=200)

当系统检测到指定GPIO的上升沿（还可以设置为GPIO.FALLING 或GPIO.BOTH）时，就会自动调用指定的回调函数my＿callback（函数的参数是按键的编号），用户程序无需再调用这个函数。add＿event＿detect 函数的最后一个参数是软件消抖的延时毫秒数，用于防止由于按键的抖动引起的错误调用。

#### 2.3.3 PWM信号输出

数字端口的输出只能是高和低两种状态，如果用来控制LED就只有亮和灭两种状态。但如果这个连接了LED的端口输出一个方波，则这个LED就有一半的时间处于亮的状态，另外一半时间处于灭的状态。当方波的频率比较高的时候，人看起来这个LED就是一种半暗的状态。

更进一步，当控制输出的方波有不同的占空比的时候，LED的亮度就会有不同的变化，从宏观上看就是端口的输出功率在不停的变化。这种输出信号的形式就叫做PWM（Pulse Width Modulation，脉宽调制）。下面的程序代码实现了控制LED灯产生呼吸灯效果，请在树莓派上编辑运行程序，并观察效果。
